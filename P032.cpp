/*
Minimum Multiplications to Reach End 
Given start, end, and an array arr of n numbers. At each step, the start is multiplied by any 
number in the array and then a mod operation with 100000 is done to get the new start. 
Your task is to find the minimum steps in which the end can be achieved starting from the start. 
If it is not possible to reach the end, then return -1.  
Time Complexity: O(100000 * N) N: number of multipliers, Where ‘100000’ are the total possible numbers generated by multiplication (hypothetical).
*/

#include<bits/stdc++.h>
using namespace std;

// User function Template for C++

class Solution {
  public:
    const int mod = 1e5;
    int minimumMultiplications(vector<int>& arr, int start, int end) {
        if(start == end) return 0;
        
        int steps = 0;
        queue<int> q;
        vector<bool> vis(mod,false);
        q.push(start);
        vis[start] = true;
        
        while(!q.empty()){
            int size = q.size();
            for(int i=0;i<size;i++){
                int front = q.front(); q.pop();
                if(front == end) return steps;
                for(int mul: arr) {
                    int temp = (1LL * mul * front) % mod;
                    if(!vis[temp]) {
                        vis[temp] = true;
                        q.push(temp);
                    }
                }
            }
            steps += 1;
        }
        return -1;
    }
};

int main(){
    Solution sol;
    vector<int> arr = {2, 2, 5};
    int start = 4, end = 16;
    int result = sol.minimumMultiplications(arr, start, end);
    cout << "Minimum steps: " << result << endl;
    return 0;
}